<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> jQuery插件开发 · Protea</title><meta name="description" content="jQuery插件开发 - 张聪"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/loverofmusic" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://www.ximalaya.com/2456872/follow/" target="_blank" class="nav-list-link">XIMALAYA</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/zhang-cong-84-8" target="_blank" class="nav-list-link">ZHIHU</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">jQuery插件开发</h1><div class="post-info">Jun 14, 2016</div><div class="post-content"><h4 id="最常用的两种方式："><a href="#最常用的两种方式：" class="headerlink" title="最常用的两种方式："></a>最常用的两种方式：</h4><ol>
<li>通过 <code>$.extend()</code> 来扩展jQuery</li>
<li>通过 <code>$.fn</code>  向jQuery添加新的方法</li>
</ol>
<h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>在jQuery身上添加了一个静态方法，栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">	sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + (name ? name: <span class="string">'Dude'</span>) + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.sayHello();<span class="comment">//调用</span></span><br><span class="line">$.sayHello(<span class="string">'Wayou'</span>);<span class="comment">//带参调用</span></span><br></pre></td></tr></table></figure>
<p>直接通过$符号调用，如上例当中：$.sayHello()</p>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>往$.fn上面添加一个方法，<code>方法名是插件名称</code>，然后插件代码在这个方法里面展开，栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">	<span class="comment">//example :$('a'),则this=$('a')</span></span><br><span class="line">	<span class="keyword">this</span>.css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面插件代码中，我们在this身上调用jQuery的css()方法，也就相当于在调用 $(‘a’).css()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">'a'</span>).myPlugin();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用插件后链接字体变成红色。</p>
<a id="more"></a>
<p>在插件代码里处理每个具体的元素，栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line">	<span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//对每个元素进行操作</span></span><br><span class="line">		$(<span class="keyword">this</span>).append(<span class="string">' '</span> + $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让插件支持链式调用，只需<code>return</code>一下，栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">	<span class="keyword">this</span>.css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//对每个元素进行操作</span></span><br><span class="line">		$(<span class="keyword">this</span>).append(<span class="string">' '</span> + $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个强劲的插件是可以让使用者随意定制的，在编写插件时要考虑得全面些，尽量提供合适的参数，比如现在我们不想让链接只变成红色，我们让插件的使用者自己定义显示什么颜色，要做到这一点很方便，只需要使用者在调用的时候传入一个参数即可。同时我们在插件的代码里面接收。另一方面，为了灵活，使用者可以不传递参数，插件里面会给出参数的默认值。</p>
</blockquote>
<h4 id="参数的接收——使用jQuery的extend方法"><a href="#参数的接收——使用jQuery的extend方法" class="headerlink" title="参数的接收——使用jQuery的extend方法"></a>参数的接收——使用jQuery的extend方法</h4><ul>
<li><p>给extend方法传递<strong>单个对象</strong>，这个对象会合并到jQuery身上，所以我们就可以在jQuery身上调用新合并对象里包含的方法了，像上面的例子。</p>
</li>
<li><p>给extend方法传递<strong>一个以上</strong>的参数时，它会将所有参数对象合并到第一个里。同时，如果对象中有同名属性时，合并的时候后面的会覆盖前面的。</p>
</li>
</ul>
<p>栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">		<span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">		<span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> settings = $.extend(defaults,options);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.css(&#123;</span><br><span class="line">		<span class="string">'color'</span>: settings.color,</span><br><span class="line">		<span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们调用的时候指定颜色，字体大小未指定，会运用插件里的默认值12px。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).myPlugin(&#123;<span class="string">'color'</span>:<span class="string">'#2C9929'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>同时指定颜色与字体大小：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).myPlugin(&#123;<span class="string">'color'</span>:<span class="string">'#2C9929'</span>,<span class="string">'fontSize'</span>:<span class="string">'20px'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="保护好默认参数"><a href="#保护好默认参数" class="headerlink" title="保护好默认参数"></a>保护好默认参数</h4><blockquote>
<p>注意到上面代码调用<code>extend</code>时会将<code>defaults</code>的值改变，这样不好，因为它作为插件因有的一些东西应该维持原样，另外就是如果你在后续代码中还要使用这些默认值的话，当你再次访问它时它已经被用户传进来的参数更改了。</p>
<p><strong>一个好的做法是将一个新的空对象做为<code>$.extend</code>的第一个参数，<code>defaults</code>和用户传递的参数对象紧随其后，这样做的好处是所有值被合并到这个空对象上，保护了插件里面的默认值 </strong></p>
</blockquote>
<p>栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> settings = $.extend(&#123;&#125;,defaults, options);</span><br><span class="line">    <span class="comment">//将一个空对象做为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.css(&#123;</span><br><span class="line">        <span class="string">'color'</span>: settings.color,</span><br><span class="line">        <span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，插件可以接收和处理参数后，就可以编写出更健壮而灵活的插件了。若要编写一个复杂的插件，代码量会很大，如何组织代码就成了一个需要面临的问题，没有一个好的方式来组织这些代码，整体感觉会杂乱无章，同时也不好维护，所以将插件的所有方法属性包装到一个对象上，用面向对象的思维来进行开发，无疑会使工作轻松很多。</p>
<h4 id="面向对象的插件开发"><a href="#面向对象的插件开发" class="headerlink" title="面向对象的插件开发"></a>面向对象的插件开发</h4><p>为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个<code>function</code>，同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量, 不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。</p>
<p>如果将需要的<strong>重要变量定义到对象的属性上，函数变成对象的方法</strong>，当我们需要的时候通过对象来获取，一来<strong>方便管理</strong>，二来<strong>不会影响外部命名空间</strong>，因为所有这些变量名还有方法名都是在对象内部。</p>
<p>接着上面的例子，我们可以把这个插件抽象成一个美化页面的对象，因为他的功能是设置颜色啊字体啊什么的，当然我们还可以加入其他功能比如设置下划线啊什么的。当然对于这个例子抽象成对象有点小题大做，这里仅作演示用。所以我们新建一个对象命名为<code>Beautifier</code>，然后我们在插件里使用这个对象来编码, 栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$element = ele,</span><br><span class="line">    <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">        <span class="string">'textDecoration'</span>:<span class="string">'none'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Beautifier的方法</span></span><br><span class="line">Beautifier.prototype = &#123;</span><br><span class="line">    beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">    <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">    <span class="comment">//调用其方法</span></span><br><span class="line">    <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面这样一改造，我们的代码变得更面向对象了，也更好维护和理解，<em>以后要加新功能新方法，只需向对象添加新变量及方法即可，然后在插件里实例化后即可调用新添加的东西</em>。</p>
<p>到这里，你可以更好地编写复杂的插件同时很好地组织代码了。当我们回头去看上面的代码时，其实也还是有改进空间的</p>
<h4 id="关于命名空间"><a href="#关于命名空间" class="headerlink" title="关于命名空间"></a>关于命名空间</h4><p>不仅仅是jQuery插件的开发，我们在写任何JS代码时都应该注意的一点是不要污染<code>全局命名空间</code>。因为随着你代码的增多，如果有意无意在全局范围内定义一些变量的话，最后很难<code>维护</code>，也容易跟别人写的代码有<code>冲突</code>。</p>
<p>比如你在代码中向全局window对象添加了一个变量status用于存放状态，同时页面中引用了另一个别人写的库，也向全局添加了这样一个同名变量，最后的结果肯定不是你想要的。所以不到万不得已，一般我们<strong>不会将变量定义成全局</strong>的。一个好的做法是始终用<code>自调用匿名函数包裹你的代码</code>，这样就可以完全放心，安全地将它用于任何地方了，绝对没有冲突。</p>
<h4 id="用自调用匿名函数包裹你的代码"><a href="#用自调用匿名函数包裹你的代码" class="headerlink" title="用自调用匿名函数包裹你的代码"></a>用自调用匿名函数包裹你的代码</h4><p>我们知道JavaScript中无法用花括号方便地创建作用域，但<strong>函数却可以形成一个作用域</strong>，域内的代码是无法被外界访问的。如果我们将自己的代码放入一个函数中，那么就不会污染全局命名空间，同时不会和别的代码冲突。</p>
<p>如上面我们定义了一个Beautifier全局变量，它会被附到全局的window对象上，为了防止这种事情发生，你或许会说，把所有代码放到jQuery的插件定义代码里面去啊，也就是放到$.fn.myPlugin里面。这样做倒也是种选择。但会让我们实际跟插件定义有关的代码变得臃肿，而在$.fn.myPlugin里面我们其实应该更专注于插件的调用，以及如何与jQuery互动。包裹之后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$element = ele,</span><br><span class="line">        <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Beautifier的方法</span></span><br><span class="line">    Beautifier.prototype = &#123;</span><br><span class="line">        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">        <span class="comment">//调用其方法</span></span><br><span class="line">        <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>另外还有一个好处是，自调用匿名函数里面的代码会在第一时间执行，页面准备好过后，上面的代码就将插件准备好了，以方便在后面的代码中使用插件。</p>
<p>目前为止似乎接近完美了。如果再考虑到其他一些因素，比如我们将这段代码放到页面后，前面别人写的代码没有用分号结尾，或者前面的代码将window, undefined等这些系统变量或者关键字修改掉了，正好我们又在自己的代码里面进行了使用，那结果也是不可预测的，这不是 我们想要的。我知道其实你还没太明白，下面详细介绍。</p>
<h4 id="将系统变量以变量形式传递到插件内部"><a href="#将系统变量以变量形式传递到插件内部" class="headerlink" title="将系统变量以变量形式传递到插件内部"></a>将系统变量以变量形式传递到插件内部</h4><p>来看下面的代码，你猜他会出现什么结果？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>本来别人的代码也正常工作，只是最后定义的那个函数没有用分号结尾而以，然后当页面中引入我们的插件时，报错了，我们的代码无法正常执行。</p>
<p>原因是我们用来<strong>充当自调用匿名函数的第一对括号与上面别人定义的函数相连</strong>，因为中间没有分号嘛，总之我们的代码无法正常解析了，所以报错。</p>
<p><strong>所以好的做法是我们在代码开头加一个分号</strong>，这在任何时候都是一个好的习惯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line"></span><br><span class="line">同时，**将系统变量以参数形式传递到插件内部**也是个不错的实践。</span><br><span class="line"></span><br><span class="line">当我们这样做之后，**window等系统变量在插件内部就有了一个局部的引用，可以提高访问速度，会有些许性能的提升**</span><br><span class="line"></span><br><span class="line">最后我们得到一个非常安全结构良好的代码：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$,window,document,undefined</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    <span class="comment">//blah blah blah...</span></span><br><span class="line">&#125;)(jQuery,<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>而至于这个undefined，稍微有意思一点，为了得到没有被修改的undefined，我们并没有传递这个参数，但却在接收时接收了它，因为实际并没有传，所以‘undefined’那个位置接收到的就是真实的’undefined’了。是不是有点hack的味道，值得细细体会的技术，当然不是我发明的，都是从前人的经验中学习。</p>
<p>所以最后我们的插件成了这样：</p>
<pre><code class="javascript">;(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document,undefined</span>) </span>{
    <span class="comment">//定义Beautifier的构造函数</span>
    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>{
        <span class="keyword">this</span>.$element = ele,
        <span class="keyword">this</span>.defaults = {
            <span class="string">'color'</span>: <span class="string">'red'</span>,
            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,
            <span class="string">'textDecoration'</span>: <span class="string">'none'</span>
        },
        <span class="keyword">this</span>.options = $.extend({}, <span class="keyword">this</span>.defaults, opt)
    }
    <span class="comment">//定义Beautifier的方法</span>
    Beautifier.prototype = {
        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css({
                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,
                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,
                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration
            });
        }
    }
    <span class="comment">//在插件中使用Beautifier对象</span>
    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>{
        <span class="comment">//创建Beautifier的实体</span>
        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);
        <span class="comment">//调用其方法</span>
        <span class="keyword">return</span> beautifier.beautify();
    }
})(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>);
</code></pre>
<p>一个安全，结构良好，组织有序的插件编写完成。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10/06/fff/" class="prev">PREV</a><a href="/2016/06/11/我的第一篇测试文章/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2016/06/14/jQuery插件开发/';
var disqus_title = 'jQuery插件开发';
var disqus_url = 'http://loverofmusic.github.io/2016/06/14/jQuery插件开发/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://loverofmusic.github.io">张聪</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>